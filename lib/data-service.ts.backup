import fs from 'fs'
import path from 'path'
import axios from 'axios';

const DATABASE_DIR = path.join(process.cwd(), 'data')
const DATABASE_FILE = path.join(DATABASE_DIR, 'database.json')
const CACHE_DURATION = 5 * 60 * 1000 // 5 minutos

// Garantir que o diret√≥rio data existe
if (!fs.existsSync(DATABASE_DIR)) {
  fs.mkdirSync(DATABASE_DIR, { recursive: true })
}

// Define WP API Endpoints
const WP_API_BASE = 'https://lcj-educa.com/wp-json/wp/v2';
const CATEGORIES_ENDPOINT = `${WP_API_BASE}/categories`;
const POSTS_ENDPOINT = `${WP_API_BASE}/posts`;

// Improved database structure to better handle categories and hierarchy
interface DatabaseStructure {
  lastUpdated: number
  categories: {
    [categoryId: string]: {
      id: number
      name: string
      description: string
      slug: string
      parent: number
      count: number // Number of posts directly in this category
      children: number[] // IDs of child categories
    }
  }
  posts: any[] // All posts in a single array
  categoryPosts: {
    [categoryId: string]: number[] // Store just post IDs for each category
  }
}

// Category type from WordPress API
interface WPCategory {
  id: number
  name: string
  slug: string
  description: string
  parent: number
  count: number
  [key: string]: any
}

// Function to initialize the database if it doesn't exist
function initializeDatabase(): DatabaseStructure {
  if (!fs.existsSync(DATABASE_FILE)) {
    const initialData: DatabaseStructure = {
      lastUpdated: 0,
      categories: {},
      posts: [],
      categoryPosts: {}
    }
    fs.writeFileSync(DATABASE_FILE, JSON.stringify(initialData))
    return initialData
  }
  
  try {
    const data = fs.readFileSync(DATABASE_FILE, 'utf8')
    return JSON.parse(data)
  } catch (error) {
    console.error('Erro ao ler banco de dados:', error)
    const initialData: DatabaseStructure = {
      lastUpdated: 0,
      categories: {},
      posts: [],
      categoryPosts: {}
    }
    fs.writeFileSync(DATABASE_FILE, JSON.stringify(initialData))
    return initialData
  }
}

// Check if database is stale
function isDatabaseStale(): boolean {
  try {
    const db = initializeDatabase()
    const now = Date.now()
    return now - db.lastUpdated > CACHE_DURATION
  } catch (error) {
    console.error('Erro ao verificar atualiza√ß√£o do banco:', error)
    return true
  }
}

// Fetch all categories in a single request
async function fetchAllCategories(): Promise<WPCategory[]> {
  try {
    console.log('Fetching all categories...');
    const allCategories: WPCategory[] = [];
    let page = 1;
    let hasMore = true;
    
    // WordPress pagination - get all categories
    while (hasMore) {
      const response = await axios.get(`${CATEGORIES_ENDPOINT}?per_page=100&page=${page}`);
      const categories = response.data;
      
      if (categories.length === 0) {
        hasMore = false;
      } else {
        allCategories.push(...categories);
        page++;
      }
    }
    
    console.log(`Fetched ${allCategories.length} categories`);
    return allCategories;
  } catch (error) {
    console.error('Error fetching categories:', error);
    throw error;
  }
}

// Fetch all posts in a single operation (paginated but in one function)
async function fetchAllPosts(): Promise<any[]> {
  try {
    console.log('Fetching all posts...');
    const allPosts: any[] = [];
    let page = 1;
    let hasMore = true;
    
    // WordPress pagination - get all posts
    while (hasMore) {
      const response = await axios.get(`${POSTS_ENDPOINT}?per_page=100&page=${page}`);
      const posts = response.data;
      
      if (posts.length === 0) {
        hasMore = false;
      } else {
        allPosts.push(...posts);
        page++;
        console.log(`Fetched page ${page-1}, got ${posts.length} posts, total so far: ${allPosts.length}`);
      }
    }
    
    console.log(`Fetched all ${allPosts.length} posts successfully`);
    return allPosts;
  } catch (error) {
    console.error('Error fetching posts:', error);
    throw error;
  }
}

// Build category hierarchy and populate children
function buildCategoryHierarchy(categories: WPCategory[]): { 
  [id: string]: { 
    id: number,
    name: string,
    description: string,
    slug: string,
    parent: number,
    count: number,
    children: number[] 
  } 
} {
  const categoryMap: any = {};
  
  // First pass: create entries for each category
  categories.forEach(category => {
    categoryMap[category.id] = {
      id: category.id,
      name: category.name,
      description: category.description,
      slug: category.slug,
      parent: category.parent,
      count: category.count,
      children: []
    };
  });
  
  // Second pass: populate children arrays
  categories.forEach(category => {
    if (category.parent && categoryMap[category.parent]) {
      categoryMap[category.parent].children.push(category.id);
    }
  });
  
  return categoryMap;
}

// Organize posts by category
function organizePostsByCategory(posts: any[]): { [categoryId: string]: number[] } {
  const categoryPosts: { [categoryId: string]: number[] } = {};
  
  posts.forEach(post => {
    if (post.categories && Array.isArray(post.categories)) {
      post.categories.forEach((categoryId: number) => {
        const catId = String(categoryId);
        if (!categoryPosts[catId]) {
          categoryPosts[catId] = [];
        }
        categoryPosts[catId].push(post.id);
      });
    }
  });
  
  return categoryPosts;
}

// Update the entire database at once
export async function updateDatabase(maxRetries = 3): Promise<boolean> {
  let retryCount = 0;
  
  while (retryCount <= maxRetries) {
    try {
      console.log(`Atualizando banco de dados (tentativa ${retryCount + 1})...`);
      
      // Step 1: Fetch all categories at once
      const allCategories = await fetchAllCategories();
      const categoryMap = buildCategoryHierarchy(allCategories);
      
      // Step 2: Fetch all posts at once
      const allPosts = await fetchAllPosts();
      
      // Step 3: Organize posts by category
      const categoryPosts = organizePostsByCategory(allPosts);
      
      // Step 4: Build the new database
      const newDb: DatabaseStructure = {
        lastUpdated: Date.now(),
        categories: categoryMap,
        posts: allPosts,
        categoryPosts: categoryPosts
      };
      
      // Step 5: Save to temp file first to prevent corruption
      const tempFilePath = `${DATABASE_FILE}.temp`;
      fs.writeFileSync(tempFilePath, JSON.stringify(newDb, null, 2));
      
      // Step 6: Rename to replace the original file
      fs.renameSync(tempFilePath, DATABASE_FILE);
      
      console.log(`Banco de dados atualizado com sucesso. ${allPosts.length} posts e ${allCategories.length} categorias processadas.`);
      return true;
      
    } catch (error) {
      console.error(`Erro ao atualizar banco de dados (tentativa ${retryCount + 1}):`, error);
      retryCount++;
      
      if (retryCount <= maxRetries) {
        const waitTime = 2000 * retryCount;
        console.log(`Tentando novamente em ${waitTime/1000} segundos...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
  }
  
  console.error(`‚ùå Falha na atualiza√ß√£o do banco de dados ap√≥s ${maxRetries} tentativas.`);
  return false;
}

// Get all subcategory IDs recursively
function getAllSubcategoryIds(categoryMap: any, categoryId: number | string): number[] {
  const stringId = String(categoryId);
  const category = categoryMap[stringId];
  
  if (!category) return [];
  
  let result: number[] = [];
  if (category.children.length > 0) {
    // Add immediate children
    result = [...category.children];
    
    // Recursively add grandchildren
    for (const childId of category.children) {
      const grandchildren = getAllSubcategoryIds(categoryMap, childId);
      result = [...result, ...grandchildren];
    }
  }
  
  return result;
}

// Enhanced version of getCategoryPosts that uses the new database structure
export async function getCategoryPosts(categoryId: number | string, options: {
  page: number,
  search: string,
  sort: string,
  categories?: string[],
  subcategory?: string,
  includeSubcategories?: boolean
}) {
  try {
    const stringCategoryId = String(categoryId);
    console.log(`üîç Getting posts for category ${stringCategoryId}`);
    
    // Read database
    const db = initializeDatabase();
    
    // Check if category exists
    if (!db.categories[stringCategoryId]) {
      console.log(`‚ö†Ô∏è Category ${stringCategoryId} not found in database.`);
      return {
        posts: [],
        totalPages: 0,
        category: null,
        categories: Object.values(db.categories),
        subcategories: [],
        totalResults: 0
      };
    }
    
    // Get all post IDs for this category
    let postIds: number[] = [];
    
    // Get direct posts for this category
    if (db.categoryPosts[stringCategoryId]) {
      postIds = [...db.categoryPosts[stringCategoryId]];
    }
    
    // Include subcategories posts unless specifically excluded
    if (options.includeSubcategories !== false) {
      // Get all subcategories
      const allSubcategories = getAllSubcategoryIds(db.categories, stringCategoryId);
      console.log(`Found ${allSubcategories.length} subcategories for category ${stringCategoryId}`);
      
      // Add posts from all subcategories
      allSubcategories.forEach(subCatId => {
        const subCatStringId = String(subCatId);
        if (db.categoryPosts[subCatStringId]) {
          postIds = [...postIds, ...db.categoryPosts[subCatStringId]];
        }
      });
    }
    
    // Remove duplicates
    postIds = [...new Set(postIds)];
    console.log(`Found ${postIds.length} total posts for category ${stringCategoryId} and its subcategories`);
    
    // Get the actual post objects using IDs
    let posts = postIds.map(id => db.posts.find(p => p.id === id)).filter(Boolean);
    
    // Apply search filter if needed
    if (options.search && options.search.trim() !== '') {
      const searchLower = options.search.toLowerCase();
      
      posts = posts.filter(post => {
        const title = typeof post.title === 'object' ? post.title.rendered : post.title;
        const content = typeof post.content === 'object' ? post.content.rendered : post.content;
        const excerpt = typeof post.excerpt === 'object' ? post.excerpt.rendered : post.excerpt;
        
        return (title && title.toLowerCase().includes(searchLower)) || 
               (content && content.toLowerCase().includes(searchLower)) ||
               (excerpt && excerpt.toLowerCase().includes(searchLower));
      });
      
      console.log(`Search for "${options.search}" returned ${posts.length} results`);
    }
    
    // Filter by additional categories if specified
    if (options.categories && options.categories.length > 0) {
      const selectedCategoryIds = new Set(options.categories.map(String));
      
      posts = posts.filter(post => {
        if (!post.categories || !Array.isArray(post.categories)) return false;
        
        return post.categories.some((catId: number) => 
          selectedCategoryIds.has(String(catId))
        );
      });
      
      console.log(`Filtering by categories ${options.categories.join(', ')} returned ${posts.length} posts`);
    }
    
    // Apply specific subcategory filter if needed
    if (options.subcategory) {
      posts = posts.filter(post => {
        if (!post.categories || !Array.isArray(post.categories)) return false;
        return post.categories.includes(Number(options.subcategory));
      });
      
      console.log(`Filtering by specific subcategory ${options.subcategory} returned ${posts.length} posts`);
    }
    
    // Apply sorting
    if (options.sort) {
      switch (options.sort) {
        case 'recent':
          posts.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
          break;
        case 'oldest':
          posts.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
          break;
        case 'title':
          posts.sort((a, b) => {
            const titleA = typeof a.title === 'object' ? a.title.rendered : a.title;
            const titleB = typeof b.title === 'object' ? b.title.rendered : b.title;
            return titleA.localeCompare(titleB);
          });
          break;
        case 'random':
          posts = [...posts].sort(() => Math.random() - 0.5);
          break;
        default:
          posts = posts.sort((a, b) => {
            // Extract date values
            let dateA, dateB;
            
            // Use specific order of properties to find date
            const dateProperties = ['date', 'date_gmt', 'created_at', 'timestamp'];
            
            // Find first valid date property for post A
            for (const prop of dateProperties) {
              if (a[prop]) {
                try {
                  const parsed = new Date(a[prop]);
                  if (!isNaN(parsed.getTime())) {
                    dateA = parsed.getTime();
                    break;
                  }
                } catch (e) {
                  continue;
                }
              }
            }
            
            // Find first valid date property for post B
            for (const prop of dateProperties) {
              if (b[prop]) {
                try {
                  const parsed = new Date(b[prop]);
                  if (!isNaN(parsed.getTime())) {
                    dateB = parsed.getTime();
                    break;
                  }
                } catch (e) {
                  continue;
                }
              }
            }
            
            // If no valid date found, use 0 (oldest possible)
            if (dateA === undefined) dateA = 0;
            if (dateB === undefined) dateB = 0;
            
            // Sort as specified (assuming isAsc is defined somewhere, otherwise default to false)
            const isAsc = false; // Default to descending (newest first)
            return isAsc ? dateA - dateB : dateB - dateA;
          });
          break;
      }
    }
    
    // Get total results count
    const totalResults = posts.length;
    
    // Apply pagination
    const perPage = 10;
    const totalPages = Math.ceil(totalResults / perPage);
    const page = options.page || 1;
    const startIndex = (page - 1) * perPage;
    const endIndex = startIndex + perPage;
    
    // Get subcategories for this category to return with result
    const subcategories = db.categories[stringCategoryId]?.children?.map(
      childId => db.categories[String(childId)]
    ) || [];
    
    // Return paginated results and metadata
    return {
      posts: posts.slice(startIndex, endIndex),
      totalPages,
      totalResults,
      category: db.categories[stringCategoryId],
      subcategories,
      categories: Object.values(db.categories)
    };
    
  } catch (error) {
    console.error('Error in getCategoryPosts:', error);
    throw error;
  }
}

// Make sure the database exists before use
export async function ensureDatabaseExists(): Promise<boolean> {
  if (!fs.existsSync(DATABASE_FILE) || isDatabaseStale()) {
    console.log('Database does not exist or is stale. Updating...');
    return updateDatabase();
  }
  return true;
}

// Get all categories with their hierarchical structure
export function getCategoryHierarchy() {
  const db = initializeDatabase();
  return Object.values(db.categories);
}

// Get direct subcategories of a category
export function getDirectSubcategories(categoryId: number | string) {
  const db = initializeDatabase();
  const stringId = String(categoryId);
  
  if (!db.categories[stringId]) {
    return [];
  }
  
  // Return the children directly from the category
  const category = db.categories[stringId];
  if (category && category.children) {
    return category.children.map(childId => db.categories[String(childId)]);
  }
  
  return [];
}

// Fun√ß√£o para buscar todos os posts de uma categoria
export function getAllCategoryPosts(categoryId: number) {
  try {
    // Verificar se precisa atualizar
    if (isDatabaseStale()) {
      console.log('Banco de dados desatualizado, atualizando em segundo plano...')
      updateDatabase().catch(err => console.error('Erro na atualiza√ß√£o autom√°tica:', err))
    }
    
    // Ler banco de dados
    const db = initializeDatabase()
    
    // Verificar se a categoria existe
    if (!db.categories[categoryId]) {
      console.log(`Categoria ${categoryId} n√£o encontrada no banco de dados`)
      return {
        posts: [],
        category: null,
        totalPosts: 0
      }
    }
    
    return {
      posts: db.categories[categoryId].posts,
      category: db.categories[categoryId].info,
      totalPosts: db.categories[categoryId].posts.length
    }
  } catch (error) {
    console.error('Erro ao buscar todos os posts do banco de dados local:', error)
    return {
      posts: [],
      category: null,
      totalPosts: 0
    }
  }
}

// Manter as fun√ß√µes originais para compatibilidade
export async function getCarouselPosts() {
  // Implementa√ß√£o existente
  const cacheKey = 'carousel-posts'
  const cachePath = getCachePath(cacheKey)
  
  if (isCacheValid(cachePath)) {
    const cacheData = fs.readFileSync(cachePath, 'utf8')
    return JSON.parse(cacheData)
  }
  
  try {
    const posts = await fetchPosts()
    fs.writeFileSync(cachePath, JSON.stringify(posts))
    return posts
  } catch (error) {
    console.error('Error fetching carousel posts:', error)
    
    if (fs.existsSync(cachePath)) {
      const cacheData = fs.readFileSync(cachePath, 'utf8')
      return JSON.parse(cacheData)
    }
    
    return []
  }
}

// Substitua a fun√ß√£o getAllAvailableCategories por esta vers√£o mais robusta
function getAllAvailableCategories(db) {
  try {
    const categoriesArray = [];
    
    if (!db || !db.categories) {
      return [];
    }
    
    // Para cada categoria no banco de dados
    for (const catId in db.categories) {
      if (db.categories[catId] && db.categories[catId].info) {
        const category = db.categories[catId].info;
        
        const cleanCategory = {
          id: category.id || catId,
          name: category.name || `Categoria ${catId}`,
          slug: category.slug,
          count: category.count || 0,
          parent: category.parent
        };
        
        categoriesArray.push(cleanCategory);
      } else {
        categoriesArray.push({
          id: catId,
          name: `Categoria ${catId}`,
          count: 0
        });
      }
    }
    
    // Se n√£o h√° categorias, adicionar exemplos
    if (categoriesArray.length === 0) {
      categoriesArray.push(
        { id: "1", name: "Categoria Exemplo 1", count: 5 },
        { id: "2", name: "Categoria Exemplo 2", count: 3 },
        { id: "3", name: "Categoria Exemplo 3", count: 7 }
      );
    }
    
    return categoriesArray;
  } catch (error) {
    console.error('‚ùå Erro ao extrair todas as categorias:', error);
    return [
      { id: "error1", name: "Erro ao carregar categorias", count: 0 }
    ];
  }
}

// Add this function to fetch all available category IDs
async function fetchAllCategoryIds() {
  try {
    console.log('üìä Buscando todas as categorias dispon√≠veis...');
    // WordPress REST API endpoint for categories
    const response = await axios.get("https://lcj-educa.com/?rest_route=/wp/v2/categories", {
      params: {
        per_page: 100, // Maximum allowed by WordPress API
        _fields: 'id,name,parent,slug,count' // Get only what we need
      }
    });
    
    if (!response.data || !Array.isArray(response.data)) {
      console.error('‚ùå Resposta inv√°lida ao buscar categorias:', response.data);
      return [21, 22]; // Default fallback
    }
    
    const categories = response.data;
    console.log(`‚úÖ Encontradas ${categories.length} categorias (incluindo subcategorias)`);
    
    // Extract IDs from response
    return categories.map(category => category.id);
  } catch (error) {
    console.error('‚ùå Erro ao buscar IDs de categorias:', error);
    // Return default categories as fallback
    return [21, 22, 27, 28, 31, 32];
  }
}

// Add this function near getCategoryPosts
async function fetchCategoryOnDemand(categoryId: number) {
  console.log(`Categoria ${categoryId} n√£o encontrada no cache, buscando sob demanda...`);
  try {
    const response = await fetchCategoryPosts(categoryId, {
      page: 1,
      search: "",
      type: "all",
      sortBy: "recent"
    });
    
    // Add to database
    const db = initializeDatabase();
    db.categories[categoryId] = {
      info: response.category,
      posts: response.posts
    };
    
    // Save to database
    fs.writeFileSync(DATABASE_FILE, JSON.stringify(db));
    
    return db.categories[categoryId];
  } catch (error) {
    console.error(`Erro ao buscar categoria ${categoryId} sob demanda:`, error);
    return null;
  }
}

// Add this function after updateDatabase()

// Function to ensure the database directory exists
function ensureDatabaseDirectory() {
  if (!fs.existsSync(DATABASE_DIR)) {
    console.log(`üìÇ Criando diret√≥rio ${DATABASE_DIR}...`);
    try {
      fs.mkdirSync(DATABASE_DIR, { recursive: true });
      console.log(`‚úÖ Diret√≥rio ${DATABASE_DIR} criado com sucesso`);
    } catch (error) {
      console.error(`‚ùå Erro ao criar diret√≥rio ${DATABASE_DIR}:`, error);
      throw error;
    }
  }
}

// Enhanced database existence check with detailed logging
export async function ensureDatabaseExists(): Promise<boolean> {
  try {
    console.log(`üîç Verificando banco de dados em ${DATABASE_FILE}...`);
    
    // Make sure the directory exists
    ensureDatabaseDirectory();
    
    // Check if database file exists
    const databaseExists = fs.existsSync(DATABASE_FILE);
    
    if (!databaseExists) {
      console.log('‚ö†Ô∏è Banco de dados n√£o encontrado. Criando novo...');
      
      // Initialize empty database structure
      const initialData = {
        lastUpdated: 0,
        categories: {}
      };
      
      // Write initial structure to file
      fs.writeFileSync(DATABASE_FILE, JSON.stringify(initialData, null, 2));
      console.log(`‚úÖ Estrutura inicial do banco de dados criada em ${DATABASE_FILE}`);
      
      // Now update the database with API data
      console.log('üîÑ Inicializando banco de dados com dados da API...');
      return await updateDatabase();
    }
    
    // If database exists, check if content is valid
    try {
      const fileContent = fs.readFileSync(DATABASE_FILE, 'utf8');
      JSON.parse(fileContent); // Test if it's valid JSON
      console.log('‚úì Conte√∫do do banco de dados validado com sucesso');
    } catch (jsonError) {
      console.error('‚ö†Ô∏è Banco de dados existente cont√©m JSON inv√°lido, recriando...');
      
      // Initialize empty database structure
      const initialData = {
        lastUpdated: 0,
        categories: {}
      };
      
      // Write initial structure to file
      fs.writeFileSync(DATABASE_FILE, JSON.stringify(initialData, null, 2));
      console.log(`‚úÖ Banco de dados recriado com estrutura inicial`);
      
      // Now update the database with API data
      return await updateDatabase();
    }
    
    // If database exists and is valid, check if it's stale
    if (isDatabaseStale()) {
      console.log('‚è±Ô∏è Banco de dados desatualizado. Atualizando...');
      try {
        const updated = await updateDatabase();
        if (!updated) {
          console.log('‚ö†Ô∏è Falha na atualiza√ß√£o autom√°tica, mas o banco de dados existe');
          return true; // Return true anyway since the database exists
        }
        return true;
      } catch (updateError) {
        console.error('‚ö†Ô∏è Erro na atualiza√ß√£o autom√°tica:', updateError);
        return true; // Return true anyway since the database exists
      }
    }
    
    console.log('‚úÖ Banco de dados existe e est√° atualizado.');
    return true;
  } catch (error) {
    console.error('‚ùå Erro ao verificar/criar banco de dados:', error);
    return false;
  }
}

// Enhanced version of getAllPosts to properly extract data regardless of structure
export function getAllPosts() {
  try {
    console.log('üîç Getting all posts from database...');
    const db = initializeDatabase();
    
    // Log database structure to help debug
    console.log(`üìä Database structure keys: ${Object.keys(db).join(', ')}`);
    
    // Extract all posts from all categories
    let allPosts = [];
    
    // Method 1: Check if we have allPosts array at the root level
    if (db.allPosts && Array.isArray(db.allPosts) && db.allPosts.length > 0) {
      console.log(`Found ${db.allPosts.length} posts in db.allPosts array`);
      allPosts = db.allPosts;
    }
    // Method 2: If you have categories structure
    else if (db.categories && Object.keys(db.categories).length > 0) {
      console.log(`Found ${Object.keys(db.categories).length} categories to extract posts from`);
      
      Object.keys(db.categories).forEach(categoryId => {
        const categoryPosts = db.categories[categoryId]?.posts || [];
        console.log(`Category ${categoryId} has ${categoryPosts.length} posts`);
        allPosts = [...allPosts, ...categoryPosts];
      });
    }
    // Method 3: Try posts at the root level
    else if (db.posts && Array.isArray(db.posts)) {
      console.log(`Found ${db.posts.length} posts in db.posts array`);
      allPosts = db.posts;
    }
    
    if (allPosts.length === 0) {
      console.log('‚ö†Ô∏è No posts found in any expected location in the database');
      // Dump a sample of the database structure to help debugging
      console.log('Database sample:', JSON.stringify(db).substring(0, 500) + '...');
    } else {
      console.log(`‚úÖ Found ${allPosts.length} total posts across all categories`);
    }
    
    // Process each post to ensure it has necessary fields
    const processedPosts = allPosts.map(post => {
      // Skip if post is null or undefined
      if (!post) return null;
      
      // Ensure excerpt is extracted properly
      let plainExcerpt = '';
      if (post.plainExcerpt) {
        plainExcerpt = post.plainExcerpt;
      } else if (post.excerpt) {
        if (typeof post.excerpt === 'object' && post.excerpt.rendered) {
          plainExcerpt = post.excerpt.rendered
            .replace(/<\/?[^>]+(>|$)/g, "")
            .replace(/&hellip;/g, "...")
            .trim();
        } else if (typeof post.excerpt === 'string') {
          plainExcerpt = post.excerpt
            .replace(/<\/?[^>]+(>|$)/g, "")
            .replace(/&hellip;/g, "...")
            .trim();
        }
      } else if (post.content) {
        if (typeof post.content === 'object' && post.content.rendered) {
          plainExcerpt = post.content.rendered
            .replace(/<\/?[^>]+(>|$)/g, "")
            .replace(/&hellip;/g, "...")
            .trim()
            .substring(0, 150) + '...';
        } else if (typeof post.content === 'string') {
          plainExcerpt = post.content
            .replace(/<\/?[^>]+(>|$)/g, "")
            .replace(/&hellip;/g, "...")
            .trim()
            .substring(0, 150) + '...';
        }
      }
      
      // Ensure date is formatted properly
      let formattedDate = null;
      if (post.formattedDate) {
        formattedDate = post.formattedDate;
      } else if (post.date) {
        try {
          formattedDate = new Date(post.date).toLocaleDateString('pt-BR', {
            day: '2-digit', 
            month: '2-digit', 
            year: 'numeric'
          });
        } catch (e) {
          console.error(`Error formatting date for post ${post.id}:`, e);
        }
      } else if (post.created_at) {
        try {
          formattedDate = new Date(post.created_at).toLocaleDateString('pt-BR', {
            day: '2-digit', 
            month: '2-digit', 
            year: 'numeric'
          });
        } catch (e) {
          console.error(`Error formatting date for post ${post.id}:`, e);
        }
      }
      
      return {
        ...post,
        plainExcerpt,
        formattedDate
      };
    })
    .filter(post => post !== null); // Remove null posts
    
    return { posts: processedPosts };
  } catch (error) {
    console.error('‚ùå Error getting all posts:', error);
    return { posts: [] };
  }
}

// Add a helper function to extract plain text if not already present
function extractPlainText(content) {
  if (!content) return '';
  
  // If it's an object with a rendered property (WordPress format)
  if (typeof content === 'object' && content.rendered) {
    return content.rendered
      .replace(/<\/?[^>]+(>|$)/g, "") // Remove HTML tags
      .replace(/&hellip;/g, "...") // Replace HTML entities
      .trim();
  }
  
  // If it's already a string
  if (typeof content === 'string') {
    return content
      .replace(/<\/?[^>]+(>|$)/g, "") // Remove HTML tags
      .replace(/&hellip;/g, "...") // Replace HTML entities
      .trim();
  }
  
  return '';
}

// Add this function to build a hierarchical structure of categories
export function getCategoryHierarchy(db) {
  try {
    // Get all categories as flat array
    const allCategories = getAllAvailableCategories(db);
    
    // Create a map for quick category lookup by ID
    const categoryMap = {};
    allCategories.forEach(category => {
      // Make sure we have consistent ID types (string)
      const id = String(category.id);
      categoryMap[id] = {
        ...category,
        children: [] // Will hold subcategories
      };
    });
    
    // Build the hierarchy
    const rootCategories = [];
    
    // For each category, add it to its parent's children array
    allCategories.forEach(category => {
      const id = String(category.id);
      const parent = category.parent ? String(category.parent) : null;
      
      if (parent && categoryMap[parent]) {
        // Add as child to parent
        categoryMap[parent].children.push(categoryMap[id]);
      } else {
        // This is a root category
        rootCategories.push(categoryMap[id]);
      }
    });
    
    return {
      hierarchy: rootCategories,
      flatMap: categoryMap
    };
  } catch (error) {
    console.error('‚ùå Erro ao criar hierarquia de categorias:', error);
    return {
      hierarchy: [],
      flatMap: {}
    };
  }
}

// Function to get subcategories of a specific category
export function getSubcategories(categoryId) {
  try {
    const db = initializeDatabase();
    const { flatMap } = getCategoryHierarchy(db);
    
    // Get the category with the given ID
    const categoryKey = String(categoryId);
    const category = flatMap[categoryKey];
    
    if (!category) return [];
    
    // Return its children
    return category.children || [];
  } catch (error) {
    console.error(`‚ùå Erro ao buscar subcategorias para categoria ${categoryId}:`, error);
    return [];
  }
}

// At the bottom of the file, keep only this one:
console.log('üöÄ Inicializando servi√ßo de dados...');
ensureDatabaseExists().catch(error => {
  console.error('‚ùå Falha na inicializa√ß√£o do banco de dados:', error);
});

// Vari√°veis de controle para atualiza√ß√£o
const UPDATE_INTERVAL = 5 * 60 * 1000; // 5 minutos em milissegundos
let isUpdateInProgress = false;
let lastUpdateAttempt = 0;

// Fun√ß√£o para verificar se os posts mudaram
function havePostsChanged(existingPosts, newPosts) {
  if (!existingPosts || !Array.isArray(existingPosts) || !newPosts || !Array.isArray(newPosts)) {
    return true;
  }
  
  // Verifica√ß√£o r√°pida: n√∫mero diferente de posts
  if (existingPosts.length !== newPosts.length) {
    console.log(`üìä Altera√ß√£o detectada: ${existingPosts.length} posts antigos vs ${newPosts.length} novos`);
    return true;
  }
  
  // Criar um mapa dos posts existentes por ID para busca r√°pida
  const existingPostsMap = new Map();
  existingPosts.forEach(post => {
    if (post && post.id) {
      existingPostsMap.set(post.id, post);
    }
  });
  
  // Verificar se algum post novo difere dos existentes
  for (const newPost of newPosts) {
    if (!newPost || !newPost.id) continue;
    
    const existingPost = existingPostsMap.get(newPost.id);
    
    // Post n√£o existe ou data de modifica√ß√£o diferente
    if (!existingPost) {
      console.log(`üìù Post novo detectado: ID ${newPost.id}`);
      return true;
    }
    
    // Verificar data de modifica√ß√£o (que pode estar em v√°rios campos)
    const newModified = newPost.modified || newPost.modified_gmt || newPost.date_modified || '';
    const oldModified = existingPost.modified || existingPost.modified_gmt || existingPost.date_modified || '';
    
    if (newModified !== oldModified) {
      console.log(`üîÑ Post modificado detectado: ID ${newPost.id}`);
      return true;
    }
  }
  
  return false;
}

// Fun√ß√£o para buscar todos os posts da API WordPress
async function fetchAllPostsFromAPI() {
  let totalPosts = 0;
  let totalPages = 1;
  let currentPage = 1;
  const perPage = 100; // M√°ximo permitido pela API WordPress
  
  const allPosts = [];
  let keepFetching = true;
  
  console.log('üì• Buscando posts da API WordPress...');
  
  while (keepFetching) {
    try {
      console.log(`üìÑ Buscando p√°gina ${currentPage}...`);
      const response = await axios.get('https://lcj-educa.com/?rest_route=/wp/v2/posts', {
        params: {
          per_page: perPage,
          page: currentPage,
          _embed: 1, // Include embedded data like featured media, categories, etc.
          // Request specific fields to make response smaller
          _fields: 'id,date,modified,title,excerpt,content,slug,featured_media,categories,_embedded'
        }
      });
      
      if (response.data && Array.isArray(response.data) && response.data.length > 0) {
        // Process each post to ensure consistent data format
        const processedPosts = response.data.map(post => {
          const processedPost = {
            ...post,
            // Ensure we have formatted dates
            formattedDate: post.date ? new Date(post.date).toLocaleDateString() : null,
            formattedModified: post.modified ? new Date(post.modified).toLocaleDateString() : null,
            
            // Extract plain text excerpt
            plainExcerpt: post.excerpt?.rendered ? 
              post.excerpt.rendered.replace(/<\/?[^>]+(>|$)/g, "").trim() : 
              (typeof post.excerpt === 'string' ? post.excerpt : ''),
              
            // Get featured image URL if available
            featuredImage: post._embedded?.['wp:featuredmedia']?.[0]?.source_url || null,
            
            // Get category names if available
            categoryNames: post._embedded?.['wp:term']?.[0]?.map(cat => cat.name) || []
          };
          
          return processedPost;
        });
        
        allPosts.push(...processedPosts);
        totalPosts += response.data.length;
        
        // Verificar se h√° mais p√°ginas
        if (response.headers && response.headers['x-wp-totalpages']) {
          totalPages = parseInt(response.headers['x-wp-totalpages']);
        } else {
          // Se n√£o tiver o cabe√ßalho, mas recebemos posts completos, assumimos que h√° mais
          if (response.data.length === perPage) {
            totalPages = currentPage + 1;
          } else {
            totalPages = currentPage;
          }
        }
        
        if (currentPage >= totalPages) {
          keepFetching = false;
        } else {
          currentPage++;
        }
      } else {
        keepFetching = false;
      }
    } catch (error) {
      console.error(`‚ùå Erro ao buscar p√°gina ${currentPage}:`, error.message);
      keepFetching = false;
    }
  }
  
  console.log(`‚úÖ Buscados ${totalPosts} posts no total de ${currentPage} p√°ginas`);
  return allPosts;
}

// Atualizar o banco de dados somente se houver mudan√ßas
export async function updateDatabaseIfChanged(): Promise<boolean> {
  // Evitar atualiza√ß√µes simult√¢neas
  if (isUpdateInProgress) {
    console.log('‚è≥ Atualiza√ß√£o j√° em andamento, pulando...');
    return false;
  }
  
  try {
    isUpdateInProgress = true;
    lastUpdateAttempt = Date.now();
    
    console.log('üîç Verificando se h√° altera√ß√µes no conte√∫do...');
    
    // Verificar se o banco de dados existe
    const db = initializeDatabase();
    
    // Garantir que o diret√≥rio existe
    ensureDatabaseDirectory();
    
    // Buscar posts novos da API
    const newPosts = await fetchAllPostsFromAPI();
    
    // Comparar com os posts existentes
    const existingPosts = db.allPosts || [];
    
    if (havePostsChanged(existingPosts, newPosts)) {
      console.log('üîÑ Altera√ß√µes detectadas, atualizando banco de dados...');
      
      // Atualizar todos os posts
      db.allPosts = newPosts;
      
      // Organizar posts por categoria
      console.log('üìä Organizando posts por categoria...');
      
      // Buscar todas as categorias primeiro
      let categories;
      try {
        const categoryResponse = await axios.get('https://lcj-educa.com/?rest_route=/wp/v2/categories', {
          params: { per_page: 100 }
        });
        categories = categoryResponse.data;
        
        // Inicializar estrutura de categorias
        if (!db.categories) db.categories = {};
        
        // Atualizar informa√ß√µes das categorias
        categories.forEach(category => {
          const categoryId = category.id;
          
          if (!db.categories[categoryId]) {
            db.categories[categoryId] = {
              info: {
                id: categoryId,
                name: category.name || `Categoria ${categoryId}`,
                description: category.description || "",
                slug: category.slug || "",
                parent: category.parent || 0, // Add parent ID
                count: category.count || 0    // Add post count
              },
              posts: []
            };
          } else {
            // Atualizar informa√ß√µes, manter posts
            db.categories[categoryId].info = {
              id: categoryId,
              name: category.name || `Categoria ${categoryId}`,
              description: category.description || "",
              slug: category.slug || "",
              parent: category.parent || 0,   // Add parent ID
              count: category.count || 0      // Add post count
            };
          }
        });
      } catch (categoryError) {
        console.error('‚ùå Erro ao buscar categorias:', categoryError);
        // Continue mesmo se n√£o conseguir buscar categorias
      }
      
      // Limpar posts existentes em categorias
      for (const categoryId in db.categories) {
        if (db.categories[categoryId].posts) {
          db.categories[categoryId].posts = [];
        }
      }
      
      // Organizar posts por categoria
      newPosts.forEach(post => {
        if (post.categories && Array.isArray(post.categories)) {
          post.categories.forEach(categoryId => {
            if (db.categories[categoryId]) {
              if (!db.categories[categoryId].posts) {
                db.categories[categoryId].posts = [];
              }
              db.categories[categoryId].posts.push(post);
            }
          });
        }
      });
      
      // Atualizar timestamp
      db.lastUpdated = Date.now();
      
      // Salvar no arquivo
      const tempFilePath = `${DATABASE_FILE}.temp`;
      fs.writeFileSync(tempFilePath, JSON.stringify(db, null, 2));
      fs.renameSync(tempFilePath, DATABASE_FILE);
      
      console.log(`‚úÖ Banco de dados atualizado com ${newPosts.length} posts.`);
      return true;
    } else {
      console.log('‚úì Nenhuma altera√ß√£o detectada, banco de dados atualizado.');
      
      // Atualizar apenas o timestamp para n√£o verificar novamente t√£o cedo
      db.lastUpdated = Date.now();
      fs.writeFileSync(DATABASE_FILE, JSON.stringify(db, null, 2));
      
      return false;
    }
  } catch (error) {
    console.error('‚ùå Erro ao atualizar banco de dados:', error);
    return false;
  } finally {
    isUpdateInProgress = false;
  }
}

// Fun√ß√£o para verificar e atualizar o banco de dados quando necess√°rio
export async function checkAndUpdateDatabase(): Promise<void> {
  // Verificar se passaram 5 minutos desde a √∫ltima tentativa
  const now = Date.now();
  const timeSinceLastAttempt = now - lastUpdateAttempt;
  
  if (timeSinceLastAttempt >= UPDATE_INTERVAL) {
    console.log('‚è∞ Verificando atualiza√ß√µes ap√≥s 5 minutos...');
    updateDatabaseIfChanged().catch(error => {
      console.error('‚ùå Erro durante verifica√ß√£o de atualiza√ß√£o:', error);
    });
  }
}

// Also, add this function to check your database structure
export async function checkDatabaseStructure() {
  try {
    const db = initializeDatabase();
    
    // Count posts in various locations
    let allPostsCount = db.allPosts && Array.isArray(db.allPosts) ? db.allPosts.length : 0;
    let rootPostsCount = db.posts && Array.isArray(db.posts) ? db.posts.length : 0;
    let categoriesCount = db.categories ? Object.keys(db.categories).length : 0;
    
    // Count posts in categories
    let categoriesPostCount = 0;
    if (db.categories) {
      Object.keys(db.categories).forEach(catId => {
        const catPosts = db.categories[catId]?.posts || [];
        categoriesPostCount += catPosts.length;
      });
    }
    
    // Gather full database statistics
    const stats = {
      databaseExists: fs.existsSync(DATABASE_FILE),
      databaseSize: fs.existsSync(DATABASE_FILE) ? Math.round(fs.statSync(DATABASE_FILE).size / 1024) + ' KB' : 'N/A',
      lastUpdated: db.lastUpdated ? new Date(db.lastUpdated).toLocaleString() : 'Never',
      postCounts: {
        allPostsArray: allPostsCount,
        rootPostsArray: rootPostsCount,
        categoriesTotal: categoriesCount,
        postsInCategories: categoriesPostCount,
        totalAccessible: allPostsCount + rootPostsCount + categoriesPostCount
      },
      structureKeys: Object.keys(db)
    };
    
    return stats;
  } catch (error) {
    return {
      error: error.message,
      stack: error.stack
    };
  }
}

// Add this helper function to get direct subcategories
function getDirectSubcategories(db, parentId) {
  const subcategories = [];
  
  if (db.categories) {
    // Convert parentId to string for consistent comparison
    const parentIdStr = String(parentId);
    
    Object.keys(db.categories).forEach(catId => {
      if (db.categories[catId] && db.categories[catId].info) {
        const category = db.categories[catId].info;
        
        // Check if this category has the specified parent
        if (category.parent && String(category.parent) === parentIdStr) {
          subcategories.push({
            id: catId,
            name: category.name,
            parent: category.parent,
            slug: category.slug
          });
        }
      }
    });
  }
  
  return subcategories;
}

// Replace the existing getCategoryDisplayName function in your component:
function getCategoryName(db, categoryId) {
  if (!categoryId) return null;
  
  const categoryIdStr = String(categoryId);
  
  // Direct lookup in categories dictionary
  if (db.categories && db.categories[categoryIdStr] && db.categories[categoryIdStr].info) {
    return db.categories[categoryIdStr].info.name;
  }
  
  // Search through all categories to find by ID
  if (db.categories) {
    for (const catId in db.categories) {
      if (db.categories[catId].info && String(db.categories[catId].info.id) === categoryIdStr) {
        return db.categories[catId].info.name;
      }
    }
  }
  
  // Fallback
  return `Categoria ${categoryId}`;
}

// Add this function inside getCategoryPosts to build the category name map
function buildCategoryNameMap(db) {
  const nameMap = {};
  
  if (db.categories) {
    for (const catId in db.categories) {
      if (db.categories[catId] && db.categories[catId].info) {
        const category = db.categories[catId].info;
        nameMap[catId] = category.name;
        
        // Also map by actual ID (which might be different from key)
        if (category.id && String(category.id) !== catId) {
          nameMap[category.id] = category.name;
        }
      }
    }
  }
  
  return nameMap;
}

// Add this function to debug category issues
export async function debugCategory(categoryId: number) {
  try {
    const db = initializeDatabase();
    console.log(`üîç Debugging category ${categoryId}`);
    
    // Check if category exists
    if (!db.categories[categoryId]) {
      console.log(`‚ö†Ô∏è Category ${categoryId} not found in database`);
      console.log(`Available categories: ${Object.keys(db.categories).join(', ')}`);
      return {
        exists: false,
        availableCategories: Object.keys(db.categories),
        error: "Category not found"
      };
    }
    
    // Check if category has posts
    const posts = db.categories[categoryId].posts || [];
    console.log(`Found ${posts.length} posts for category ${categoryId}`);
    
    // Check for subcategories
    const subcategories = getDirectSubcategories(db, categoryId);
    console.log(`Found ${subcategories.length} subcategories for category ${categoryId}`);
    
    // Sample posts if available
    const samplePosts = posts.slice(0, 2).map(p => ({ 
      id: p.id, 
      title: typeof p.title === 'object' ? p.title.rendered : p.title
    }));
    
    return {
      exists: true,
      postsCount: posts.length,
      subcategories: subcategories,
      categoryName: db.categories[categoryId].info.name,
      samplePosts
    };
  } catch (error) {
    console.error(`Error debugging category ${categoryId}:`, error);
    return { exists: false, error: error.message };
  }
}